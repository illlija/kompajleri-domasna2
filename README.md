# Домашна задача 2
http://www.regexr.com/

>1. Обидете и да ги лоцирате и извлечете сите наредби (како блок од код) во рамки на for циклусите.

Решение: 
```regex
'/for *?\(.*?\)\s*({((\s|.)*?)}|[^{](.*?;))//g'
```

>2. Пробајте да напишете регуларен/ни израз/и со кој ќе ги откриете само неправилно напишаните циклуси.

Решение: 
```regex
'/for *?\(.*?\)\s*[^\s{](?:(?!(for *?\(.*?\)|if *?\(.*?\)|else *?\(.*?\)|else if *?\(.*?\)|do *?\(.*?\)|while *?\(.*?\)|switch *?\(.*?\)|}))(.|\s))*(?!(for *?\(.*?\)|if *?\(.*?\)|else *?\(.*?\)|else if *?\(.*?\)|do *?\(.*?\)|while *?\(.*?\)|switch *?\(.*?\)|[^}]))//g'
```


## Тестирање

`testdat1.cpp :` Позајмената датотека содржи едноставен и точен код и првиот регуларен израз точно го пронаоѓа for циклусот. Вториот регуларен израз точно пронаоѓа дека нема неправилно напишан for циклус.

`testdat2.cpp :` Првиот регуларен израз прави грешка во вгнездениот циклус, но точно го извлекува последниот. Вториот регуларен израз грешно ги извлекува вгнездениот for циклус и последниот for циклус со inline код, иако сите команди се валидни во оваа датотека. Овие грешки се должат на фактот дека во нашиот израз немаме земено во предвид рекурзивни структури и функции (забележуваме дека заградата која ја затвора main функцијата е пронајдена како причина за невалидноста на последниот циклус - регуларниот израз препознава дека недостасува отворена заграда за неговиот блок код).


## Заклучок

Иако регуларните изрази се многу корисни, сепак со зголемувањето на комплексноста на проблемот (т.е. со користење регуларни изрази за манипулации врз нерегуларен блок текст - во овој случај парсирање изворен код на C++) се зголемува и нечиткоста на изразите, а се намалува и нивната употребливост. 

Кога за некој проблем поедноставното и поефикасното решение е имплементирано во посебни алатки (како генератори на парсери) треба да ги употребиме. Во нашиот случај, на пример, употребата на CoCo-R би бил посоодветен избор.
